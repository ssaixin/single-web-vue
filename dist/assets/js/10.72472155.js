(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{368:function(n,t,e){"use strict";e.r(t);var p=e(44),a=Object(p.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"single-spa-vue-源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#single-spa-vue-源码分析"}},[n._v("#")]),n._v(" single-spa-vue 源码分析")]),n._v(" "),e("p",[n._v("single-spa-vue负责为vue应用生成通用的生命周期钩子，这些钩子函数负责子应用的初始化、挂载、更新（数据）、卸载。")]),n._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[n._v('import "css.escape";\n \nconst defaultOpts = {\n  // required opts\n  Vue: null,\n  appOptions: null,\n  template: null\n};\n \n/**\n * 判断参数的合法性\n * 返回生命周期函数，其中的mount方法负责实例化子应用，update方法提供了基座应用和子应用通信的机会，unmount卸载子应用，bootstrap感觉没啥用\n * @param {*} userOpts = {\n *    Vue,\n *    appOptions: {\n *      el: \'#id\',\n *      store,\n *      router,\n *      render: h => h(App)\n *    } \n * }\n * return 四个生命周期函数组成的对象\n */\nexport default function singleSpaVue(userOpts) {\n  // object\n  if (typeof userOpts !== "object") {\n    throw new Error(`single-spa-vue requires a configuration object`);\n  }\n \n  // 合并用户选项和默认选项\n  const opts = {\n    ...defaultOpts,\n    ...userOpts\n  };\n \n  // Vue构造函数\n  if (!opts.Vue) {\n    throw Error("single-spa-vue must be passed opts.Vue");\n  }\n \n  // appOptions\n  if (!opts.appOptions) {\n    throw Error("single-spa-vue must be passed opts.appOptions");\n  }\n \n  // el选择器\n  if (\n    opts.appOptions.el &&\n    typeof opts.appOptions.el !== "string" &&\n    !(opts.appOptions.el instanceof HTMLElement)\n  ) {\n    throw Error(\n      `single-spa-vue: appOptions.el must be a string CSS selector, an HTMLElement, or not provided at all. Was given ${typeof opts\n        .appOptions.el}`\n    );\n  }\n \n  // Just a shared object to store the mounted object state\n  // key - name of single-spa app, since it is unique\n  let mountedInstances = {};\n \n  /**\n   * 返回一个对象，每个属性都是一个生命周期函数\n   */\n  return {\n    bootstrap: bootstrap.bind(null, opts, mountedInstances),\n    mount: mount.bind(null, opts, mountedInstances),\n    unmount: unmount.bind(null, opts, mountedInstances),\n    update: update.bind(null, opts, mountedInstances)\n  };\n}\n \nfunction bootstrap(opts) {\n  if (opts.loadRootComponent) {\n    return opts.loadRootComponent().then(root => (opts.rootComponent = root));\n  } else {\n    return Promise.resolve();\n  }\n}\n \n/**\n * 做了三件事情：\n *  大篇幅的处理el元素\n *  然后是render函数\n *  实例化子应用\n */\nfunction mount(opts, mountedInstances, props) {\n  const instance = {};\n  return Promise.resolve().then(() => {\n    const appOptions = { ...opts.appOptions };\n    // 可以通过props.domElement属性单独设置自应用的渲染DOM容器，当然appOptions.el必须为空\n    if (props.domElement && !appOptions.el) {\n      appOptions.el = props.domElement;\n    }\n \n    let domEl;\n    if (appOptions.el) {\n      if (typeof appOptions.el === "string") {\n        // 子应用的DOM容器\n        domEl = document.querySelector(appOptions.el);\n        if (!domEl) {\n          throw Error(\n            `If appOptions.el is provided to single-spa-vue, the dom element must exist in the dom. Was provided as ${appOptions.el}`\n          );\n        }\n      } else {\n        // 处理DOM容器是元素的情况\n        domEl = appOptions.el;\n        if (!domEl.id) {\n          // 设置元素ID\n          domEl.id = `single-spa-application:${props.name}`;\n        }\n        appOptions.el = `#${CSS.escape(domEl.id)}`;\n      }\n    } else {\n      // 当然如果没有id，这里会自动生成一个id\n      const htmlId = `single-spa-application:${props.name}`;\n      appOptions.el = `#${CSS.escape(htmlId)}`;\n      domEl = document.getElementById(htmlId);\n      if (!domEl) {\n        domEl = document.createElement("div");\n        domEl.id = htmlId;\n        document.body.appendChild(domEl);\n      }\n    }\n \n    appOptions.el = appOptions.el + " .single-spa-container";\n \n    // single-spa-vue@>=2 always REPLACES the `el` instead of appending to it.\n    // We want domEl to stick around and not be replaced. So we tell Vue to mount\n    // into a container div inside of the main domEl\n    if (!domEl.querySelector(".single-spa-container")) {\n      const singleSpaContainer = document.createElement("div");\n      singleSpaContainer.className = "single-spa-container";\n      domEl.appendChild(singleSpaContainer);\n    }\n \n    instance.domEl = domEl;\n \n    // render\n    if (!appOptions.render && !appOptions.template && opts.rootComponent) {\n      appOptions.render = h => h(opts.rootComponent);\n    }\n \n    // data\n    if (!appOptions.data) {\n      appOptions.data = {};\n    }\n \n    appOptions.data = { ...appOptions.data, ...props };\n \n    // 实例化子应用\n    instance.vueInstance = new opts.Vue(appOptions);\n    if (instance.vueInstance.bind) {\n      instance.vueInstance = instance.vueInstance.bind(instance.vueInstance);\n    }\n \n    mountedInstances[props.name] = instance;\n \n    return instance.vueInstance;\n  });\n}\n \n// 基座应用通过update生命周期函数可以更新子应用的属性\nfunction update(opts, mountedInstances, props) {\n  return Promise.resolve().then(() => {\n    // 应用实例\n    const instance = mountedInstances[props.name];\n    // 所有的属性\n    const data = {\n      ...(opts.appOptions.data || {}),\n      ...props\n    };\n    // 更新实例对象上的属性值，vm.test = \'xxx\'\n    for (let prop in data) {\n      instance.vueInstance[prop] = data[prop];\n    }\n  });\n}\n \n// 调用$destroy钩子函数，销毁子应用\nfunction unmount(opts, mountedInstances, props) {\n  return Promise.resolve().then(() => {\n    const instance = mountedInstances[props.name];\n    instance.vueInstance.$destroy();\n    instance.vueInstance.$el.innerHTML = "";\n    delete instance.vueInstance;\n \n    if (instance.domEl) {\n      instance.domEl.innerHTML = "";\n      delete instance.domEl;\n    }\n  });\n}\n')])])]),e("p",[n._v("框架内子应用的各个状态以及状态的变更过程")]),n._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[n._v("// 实现子应用的注册、挂载、切换、卸载功能\n \n/**\n * 子应用状态\n */\n// 子应用注册以后的初始状态\nconst NOT_LOADED = 'NOT_LOADED'\n// 表示正在加载子应用源代码\nconst LOADING_SOURCE_CODE = 'LOADING_SOURCE_CODE'\n// 执行完 app.loadApp，即子应用加载完以后的状态\nconst NOT_BOOTSTRAPPED = 'NOT_BOOTSTRAPPED'\n// 正在初始化\nconst BOOTSTRAPPING = 'BOOTSTRAPPING'\n// 执行 app.bootstrap 之后的状态，表是初始化完成，处于未挂载的状态\nconst NOT_MOUNTED = 'NOT_MOUNTED'\n// 正在挂载\nconst MOUNTING = 'MOUNTING'\n// 挂载完成，app.mount 执行完毕\nconst MOUNTED = 'MOUNTED'\nconst UPDATING = 'UPDATING'\n// 正在卸载\nconst UNMOUNTING = 'UNMOUNTING'\n// 以下三种状态这里没有涉及\nconst UNLOADING = 'UNLOADING'\nconst LOAD_ERROR = 'LOAD_ERROR'\nconst SKIP_BECAUSE_BROKEN = 'SKIP_BECAUSE_BROKEN'\n \n// 存放所有的子应用\nconst apps = []\n \n/**\n * 注册子应用\n * @param {*} appConfig = {\n *    name: '',\n *    app: promise function,\n *    activeWhen: location => location.pathname.startsWith(path),\n *    customProps: {}\n * }\n */\nexport function registerApplication (appConfig) {\n  apps.push(Object.assign({}, appConfig, { status: NOT_LOADED }))\n  reroute()\n}\n \n// 启动\nlet isStarted = false\nexport function start () {\n  isStarted = true\n}\n \nfunction reroute () {\n  // 三类 app\n  const { appsToLoad, appsToMount, appsToUnmount } = getAppChanges()\n  if (isStarted) {\n    performAppChanges()\n  } else {\n    loadApps()\n  }\n \n  function loadApps () {\n    appsToLoad.map(toLoad)\n  }\n \n  function performAppChanges () {\n    // 卸载\n    appsToUnmount.map(toUnmount)\n    // 初始化 + 挂载\n    appsToMount.map(tryToBoostrapAndMount)\n  }\n}\n \n/**\n * 挂载应用\n * @param {*} app \n */\nasync function tryToBoostrapAndMount(app) {\n  if (shouldBeActive(app)) {\n    // 正在初始化\n    app.status = BOOTSTRAPPING\n    // 初始化\n    await app.bootstrap\n    // 初始化完成\n    app.status = NOT_MOUNTED\n    // 第二次判断是为了防止中途用户切换路由\n    if (shouldBeActive(app)) {\n      // 正在挂载\n      app.status = MOUNTING\n      // 挂载\n      await app.mount()\n      // 挂载完成\n      app.status = MOUNTED\n    }\n  }\n}\n \n/**\n * 卸载应用\n * @param {*} app \n */\nasync function toUnmount (app) {\n  if (app.status !== 'MOUNTED') return app\n  // 更新状态为正在卸载\n  app.status = MOUNTING\n  // 执行卸载\n  await app.unmount()\n  // 卸载完成\n  app.status = NOT_MOUNTED\n  return app\n}\n \n/**\n * 加载子应用\n * @param {*} app \n */\nasync function toLoad (app) {\n  if (app.status !== NOT_LOADED) return app\n  // 更改状态为正在加载\n  app.status = LOADING_SOURCE_CODE\n  // 加载 app\n  const res = await app.app()\n  // 加载完成\n  app.status = NOT_BOOTSTRAPPED\n  // 将子应用导出的生命周期函数挂载到 app 对象上\n  app.bootstrap = res.bootstrap\n  app.mount = res.mount\n  app.unmount = res.unmount\n  app.unload = res.unload\n  // 加载完以后执行 reroute 尝试挂载\n  reroute()\n  return app\n}\n \n/**\n * 将所有的子应用分为三大类，待加载、待挂载、待卸载\n */\nfunction getAppChanges () {\n  const appsToLoad = [],\n    appsToMount = [],\n    appsToUnmount = []\n  \n  apps.forEach(app => {\n    switch (app.status) {\n      // 待加载\n      case NOT_LOADED:\n        appsToLoad.push(app)\n        break\n      // 初始化 + 挂载\n      case NOT_BOOTSTRAPPED:\n      case NOT_MOUNTED:\n        if (shouldBeActive(app)) {\n          appsToMount.push(app)\n        } \n        break\n      // 待卸载\n      case MOUNTED:\n        if (!shouldBeActive(app)) {\n          appsToUnmount.push(app)\n        }\n        break\n    }\n  })\n  return { appsToLoad, appsToMount, appsToUnmount }\n}\n \n/**\n * 应用需要激活吗 ？\n * @param {*} app \n * return true or false\n */\nfunction shouldBeActive (app) {\n  try {\n    return app.activeWhen(window.location)\n  } catch (err) {\n    console.error('shouldBeActive function error', err);\n    return false\n  }\n}\n \n// 让子应用判断自己是否运行在基座应用中\nwindow.singleSpaNavigate = true\n// 监听路由\nwindow.addEventListener('hashchange', reroute)\nwindow.history.pushState = patchedUpdateState(window.history.pushState)\nwindow.history.replaceState = patchedUpdateState(window.history.replaceState)\n/**\n * 装饰器，增强 pushState 和 replaceState 方法\n * @param {*} updateState \n */\nfunction patchedUpdateState (updateState) {\n  return function (...args) {\n    // 当前url\n    const urlBefore = window.location.href;\n    // pushState or replaceState 的执行结果\n    const result = Reflect.apply(updateState, this, args)\n    // 执行updateState之后的url\n    const urlAfter = window.location.href\n    if (urlBefore !== urlAfter) {\n      reroute()\n    }\n    return result\n  }\n}\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);